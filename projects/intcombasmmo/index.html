<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IntComBasMMO — Geoff Wade</title>
  <link rel="stylesheet" href="/css/site.css" />
  <link rel="stylesheet" href="/css/code.css" />

  <!-- Prism syntax highlighting (static-friendly) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-okaidia.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
  <!-- C++ highlighting -->
  <script defer src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-cpp.min.js"></script>
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <a class="brand" href="/"><span class="brand-mark">◆</span><span class="brand-text">Geoff Wade</span></a>
      <nav class="nav" aria-label="Primary">
        <a href="/about/">About</a>
        <a href="/projects/">Projects</a>
        <a href="/#contact">Contact</a>
      </nav>
    </div>
  </header>

  <main class="section">
    <div class="container">
      <p class="muted"><a href="/projects/">← Back to projects</a></p>

      <div class="project-hero">
        <div>
          <h1>IntConBasMMO</h1>
          <p class="muted">
            A project where I built game mechanics for spawning and gathering resources, crafting, and basic game combat.
          </p>
          <div class="project-links">
            <a class="btn btn-solid" href="https://github.com/Geo-Wade/FuelManagementApp2" target="_blank" rel="noreferrer">Repo</a>
          </div>
          <ul class="pill-row">
            <li class="pill">C++</li>
            <li class="pill">UE4</li>
            <li class="pill">OOP</li>
          </ul>
        </div>

        <div class="card">
          <img class="project-media" src="assets/hero.png" alt="Project hero screenshot" />
        </div>
      </div>

      <section class="section tight">
        <h2>Resource Spawn Demo</h2>
        <div class="card">
          <img class="project-media" src="assets/demo01.gif" alt="Animated demo of the project" />
        </div>
      </section>

      <section class="section tight">
        <h2>Problem</h2>
        <p class="muted">
          Players need resources to spawn predictably and fairly. I needed a system that places resources logically on the terrain without clustering or breaking under crowded conditions.
        </p>
      </section>

      <section class="section tight">
        <h2>Solution</h2>
        <ul class="bullets">
          <li>Sample spawn points within a configurable volume and snap placement to terrain level</li>
          <li>Reject candidates that violate a minimum inter-resource distance</li>
          <li>imit placement attempts with a retry cap to guarantee completion even when overcrowded</li>
        </ul>
      </section>

      <section class="section tight">
        <h2>Code snippet</h2>
        <div class="card">
          <!-- IMPORTANT: keep code flush-left inside <code> to avoid extra indentation -->
          <pre class="code"><code id="snippet-area" class="language-cpp">void AICBMResourceSpawner::FindLocationToSpawn(FVector* OutVector)
{
	int NumberOfTries = 0;
	bool FoundViableLocation = false;

	do
	{
		UE_LOG(LogTemp, Warning, TEXT("trying..."))
		FVector BoxExtent = SpawningVolume-&gt;GetScaledBoxExtent();
		FVector BoxLocation = SpawningVolume-&gt;GetComponentLocation();
		float MaxX = BoxLocation.X + BoxExtent.X;
		float MinX = BoxLocation.X - BoxExtent.X;
		float X = FMath::RandRange(MinX, MaxX);

		float MaxY = BoxLocation.Y + BoxExtent.Y;
		float MinY = BoxLocation.Y - BoxExtent.Y;
		float Y = FMath::RandRange(MinY, MaxY);

		FVector TraceStart = FVector(X, Y, BoxLocation.Z + BoxExtent.Z);
		FVector TraceEnd = TraceStart;
		TraceEnd.Z = BoxLocation.Z - BoxExtent.Z;

		FHitResult Hit;
		if (GetWorld()-&gt;LineTraceSingleByChannel(Hit, TraceStart, TraceEnd, ECC_Visibility))
		{
			bool bValidClass = false;
			for (FString ClassName : ViableSpawnClasses)
			{
				if (Hit.Actor-&gt;GetClass()-&gt;GetName() == ClassName)
				{
					bValidClass = true;
				}
			}

			bool TooCloseToOtherResource = false;
			for (AICBMResourceActor* ResourceActor : ResourceActorList)
			{
				float Distance = (ResourceActor-&gt;GetActorLocation() - Hit.ImpactPoint).Size();
				if (Distance &lt; DistanceBetweenResources)
				{
					TooCloseToOtherResource = true;
				}
			}

			if (!TooCloseToOtherResource &amp;&amp; bValidClass)
			{
				FoundViableLocation = true;
				*OutVector = Hit.ImpactPoint;
			}
		}

		NumberOfTries++;
	} while (NumberOfTries &lt; 100 &amp;&amp; !FoundViableLocation);

	OutVector = NULL;
}</code></pre>
        </div>
      </section>

		<section class="section tight">
        <h2>Resource Gather Demo</h2>
        <div class="card">
          <img class="project-media" src="assets/demo02.gif" alt="Animated demo of the project" />
        </div>
      </section>

      <section class="section tight">
        <h2>Problem</h2>
        <p class="muted">
          Design a scalable tool-to-resource interaction model that supports many resource types and tool variants, while keeping the logic maintainable in Blueprints.
        </p>
      </section>

      <section class="section tight">
        <h2>Solution</h2>
        <ul class="bullets">
          <li>Created a Resource base class (C++) with Blueprint children that define world representation and inventory representation</li>
          <li>Created a Tool/Weapon base class with an allowlist of gatherable resource classes/types set in Blueprint</li>
          <li>Implemented an Inventory Component on the local Player Controller; on successful gather, the resource actor is destroyed and deposits its item payload into inventory</li>
        </ul>
      </section>

      <section class="section tight">
        <h2>Code snippet</h2>
        <div class="card">
          <!-- IMPORTANT: keep code flush-left inside <code> to avoid extra indentation -->
          <pre class="code"><code id="snippet-area" class="language-cpp">void AICBMResourceActor::GiveResourceToCharacter_Multicast_Implementation(AController* DamageingController)
{
	if (DamageingController != nullptr)
	{
		AICBMHeroCharacter* Character = Cast<AICBMHeroCharacter>(DamageingController->GetPawn());
		if (Character != nullptr && ThisItemType != nullptr)
		{
			int32 Amount = FMath::RandRange(MinAmount, MaxAmount); 
			Character->DepositInventoryItem(ThisItemType, Amount);
		}
	}
}</code></pre>
        </div>
      </section>

		<section class="section tight">
        <h2>Resource Gather Demo</h2>
        <div class="card">
          <img class="project-media" src="assets/demo03.gif" alt="Animated demo of the project" />
        </div>
      </section>

      <section class="section tight">
        <h2>Problem</h2>
        <p class="muted">
          I needed a scalable crafting system that validates required materials and delivers the crafted item to the player reliably.   
        </p>
      </section>

      <section class="section tight">
        <h2>Solution</h2>
        <ul class="bullets">
          <li>Created a Crafting Station base class designed for Blueprint inheritance</li>
          <li>Implemented material validation: check the player inventory for required inputs before crafting</li>
          <li>Built a shared inventory insert path so crafted items can be granted consistently (and reused by other world actors)</li>
        </ul>
      </section>

      <section class="section tight">
        <h2>Code snippet</h2>
        <div class="card">
          <!-- IMPORTANT: keep code flush-left inside <code> to avoid extra indentation -->
          <pre class="code"><code id="snippet-area" class="language-cpp">bool AICBMCraftingStationActor::CraftItems(UICBMInventoryItemDataAsset* CraftingItem)
{
	AICBMHeroCharacter* HeroCharacter = Cast<AICBMHeroCharacter>(ControllingActor); 
	if (HeroCharacter != nullptr)
	{
		for(FCraftingIngredients Ingredient : CraftingItem->GetRequiredIngredients())
		{
			HeroCharacter->GetInventoryComponent()->RemoveItemsFromInventory(Ingredient.RequiredIngredient, Ingredient.AmountRequied); 
		}

		FTransform SpawnTransform = MeshComp->GetSocketTransform(SocketToSpawnCraftedItem);
		FActorSpawnParameters SpawnParameters;
		AActor* SpawnedActor = GetWorld()->SpawnActor(CraftingItem->GetInventoryItemClass(),
			&SpawnTransform, SpawnParameters);
		if (SpawnedActor != nullptr)
		{
			return true;
		}
	}</code></pre>
        </div>
      </section>

      <section class="section tight">
        <h2>What I learned</h2>
        <p class="muted">  Unreal’s framework and editor create a tight feedback loop: you can validate systems in-world while iterating on code and data.
  This project strengthened my ability to design scalable, reusable gameplay systems using core OOP principles—base classes and clear
  contracts for resources, tools, and crafting stations—while keeping behavior largely data-driven through Blueprint variants.
  I also learned to build “safe” mechanics: validating inputs, enforcing constraints, and capping retries to guarantee predictable behavior.</p>
      </section>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container footer-inner">
      <p class="muted">© <span id="year"></span> Geoff Wade</p>
      <nav class="nav" aria-label="Footer">
        <a href="/">Home</a>
        <a href="/projects/">Projects</a>
        <a href="/projects/">Projects</a>
        <a href="/about/">About</a>
      </nav>
    </div>
  </footer>
</body>
</html>
